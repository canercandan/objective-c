/*
**	cnormCreateCtypeNode.inc.cws
**	for LSE - cnorm
**	made by amsall_d and giron_d
**	review by auroux_l
*/

/*
**	function (void)		cnormCreateCtypeNode(ctype : node)
**	function (void)		cnormFillCtypeNode(ctype : node, command : value, arg : value)
*/

function	cnormCreateCtypeNode(ctype : node)
/*
  This function creates a basic empty ctype node that
  can be filled safely by the function
  cnormFillCtypeNode(ctype : node, command : value, arg : value)
  
  subnodes description:

  infotype: 'auto'	: 'storageClassSpecifier'
	    'register'	: 'storageClassSpecifier'
	    'static'	: 'storageClassSpecifier'
	    'extern'	: 'storageClassSpecifier'
	    'const'	: 'typeQualifier'
	    'volatile'	: 'typeQualifier'
	    'restrict'	: 'typeQualifier'
	    'inline'	: 'functionSpecifier'
	    This node is created if needed

  type: ['primary' | 'composed'] ('__UNDEF__' by default)

  sign: ['signed' | 'unsigned']
	This subnode is created only if needed

  specifier: ['short' | 'long' | 'long long' | ...] (if type == 'primary')
	     | ['struct' | 'union' | ...] (if type == 'composed')
	     this subnode is created only if needed.
	     
  identifier: ['int' | 'char' | ...] (if type == 'primary')
	      | identifier (if type == 'composed')
	      This node can be empty in case the composed type is
	      anonymous. In such case, an arbitrary name will
	      be generated.

  pointer: This subnode is an array composed of each pointer levels,
	   'const' qualifiers or arrays found. see doc for more details,
	   such as pointed arrays or arrays of pointers....
	   Node created if needed.

  array: This subnode is an array similar to the 'array_expression' one.
	 Created if needed.

*/
{
  insert ctype.type = "__UNDEF__";
//insert ctype.infoType;
//insert ctype.sign;
//insert ctype.specifier;
  insert ctype.identifier = "__UNDEF__";
//insert ctype.pointer;
//insert ctype.array;
}


/*
**	used to error-safely fill a ctype node
*/

function	cnormFillCtypeNode(ctype : node, command : value, arg : value)
{
  switch ( command )
    {
    case "__INFOTYPE__" :
      {
	local	infoTypeName = cnormToolCtypeNode_getInfoTypeName(arg);
	insert ctype.infoType;
	cnormToolCtypeNode_fillInfoTypeValue(ctype, infoTypeName, arg);
	break;
      }
    case "__SIGN__" :
      {
	cnormToolCtypeNode_fillSignValue(ctype, arg);
	break;
      }
    case "__TYPEID__" :
      {
	cnormToolCtypeNode_fillTypeid(ctype, arg);
	break;
      }
    case "__POINTER__" :
      {
	cnormToolCtypeNode_fillPointer(ctype, arg);
	break;
      }
    case "__ARRAY__" :
      {
	/* later... */
	insert ctype.array = $ ctype.array + 1 $;
	pushItem ctype.array = arg;
	break;
      }
    default :
      {
	cnormError("Unknown fill ctype node command [" + command + "]");
	break;
      }
    }
}

function	cnormFillCtypeNodeFromArray(ctype : node, pairs : node)
/*
  contrary to cnormFillCtypeNode which can fill values one by one,
  cnormFillCtypeNodeFromArray can store multiple datas in the node
  in one time, avoiding tiresome loop calls to the cnormFillCtypeNode
  function. Usefull for handcrafted nodes.
  The pair node's shape is as in this instance:
	.pair
		[arg1] = command1
		[arg2] = command4
		[arg3] = command2
		[arg4] = command1
*/
{
  foreach pair in pairs
    { cnormFillCtypeNode(ctype, pair, pair.key()); }
}

