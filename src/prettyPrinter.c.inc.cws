/**
 * @file prettyPrinter.c.inc.cws
 * @brief PrettyPrinter to print the kooc to c
 * @note @ref develop @ref contrib @ref tools
 * @bug URGENT: plantage de kooc si on met des types struct dans
 * prototype de fonction
 */

declare function	r00t();
declare function	loopBlock(block : node);
declare function	loopArgument(block : node);
declare function	endPoint(block : node);
declare function	clearString(val : value);
declare function	blockType<T>(block : node);
declare function	prettyPrintExistFile(file : value,
					     block : node);

/**
 * @fn r00t()
 * @brief main function
 * @return loopBlock function
 */
function	r00t()
{
  return (loopBlock(this.block));
}

/**
 * @fn loopBlock(block : node)
 * @brief this function loop in a tree's block
 * @return sInfo which is the result of
 * concatenation of blockType function's return
 */
function	loopBlock(block : node)
{
  local		sInfo = "";

  foreach var in block
    sInfo += blockType<var.type>(var);
  return (sInfo);
}

/**
 * @fn loopArgument(block : node)
 * @brief like loopBlock but to function's arguments
 * @param block tree's block
 * @return e.g. loopBlock
 */
function	loopArgument(block : node)
{
  local		sInfo = "";

  foreach var in block
  {
    sInfo += blockType<var.type>(var);
    if (!last(var))
      sInfo += ", ";
  }
  return (sInfo);
}

/**
 * @fn endPoint(block : node)
 * @brief if the block is an expression, this
 * function return a break (;)
 * @param block tree's block
 * @return a break (;)
 */
function	endPoint(block : node)
{
  if (existVariable(block.etype))
    if (block.etype == "expression")
      return (";\n");
  return ("");
}

/**
 * @fn clearString(val : value)
 * @brief clear the blackslash notation in
 * val's string
 * @param val string
 * @return val
 */
function	clearString(val : value)
{
  val = replaceString('\a', "\\a", val);
  val = replaceString('\b', "\\b", val);
  val = replaceString('\f', "\\f", val);
  val = replaceString('\n', "\\n", val);
  val = replaceString('\r', "\\r", val);
  val = replaceString('\t', "\\t", val);
  val = replaceString('\v', "\\v", val);
  return (val);
}

/**
 * @fn blockType<T>(block : node)
 * @brief It's the specialisation of lot of type
 * of block in the tree
 * @param block tree's block
 */
function	blockType<T>(block : node)
{
  //traceLine("block: [" + T + "] unknown");
}

/**
 * @fn blockType<"__FUNCTION__">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo noting
 */
function	blockType<"__FUNCTION__">(block : node)
{
  local		sInfo;

  sInfo = getFunction(block)
    + "\n{\n" + loopBlock(block.block) + "}\n\n";
  return (sInfo);
}

/**
 * @fn blockType<"variable_for">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo noting
 */
function	blockType<"variable_for">(block : node)
{
  local		sInfo = "";

  if (existVariable(block.init.type))
    {
      if (block#parent#front.name == block.name)
	sInfo += getVariable(block);
      else
	sInfo += getVariableTypeLess(block);
      sInfo += " = "
	+ blockType<block.init.type>(block.init);
    }
  else
    sInfo += getVariableTypeLess(block);
  if (block#parent#back.name != block.name)
    sInfo += ", ";
  return (sInfo);
}

/**
 * @fn blockType<"variable_normal">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo noting
 */
function	blockType<"variable_normal">(block : node)
{
  local		sInfo;

  sInfo = getVariable(block);
  if (existVariable(block.init.type))
    sInfo += " = "
      + blockType<block.init.type>(block.init);
  return (sInfo + ";\n");
}

/**
 * @fn blockType<"__VARIABLE__">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo noting
 */
function	blockType<"__VARIABLE__">(block : node)
{
  if (existVariable(block#parent#parent.type) &&
      block#parent#parent.type == "for")
    return (blockType<"variable_for">(block));
  else
    return (blockType<"variable_normal">(block));
}

/**
 * @fn blockType<"return">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo noting
 */
function	blockType<"return">(block : node)
{
  local		sInfo;

  sInfo = "return";
  if (existVariable(block.block))
    sInfo += ' ' + blockType<block.block.type>(block.block);
  sInfo += ";\n";
  return (sInfo);
}

/**
 * @fn blockType<"priority_expression">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo noting
 */
function	blockType<"priority_expression">(block : node)
{
  local		sInfo;

  sInfo = '(' + blockType<block.expr.type>(block.expr) + ')';
  return (sInfo);
}

/**
 * @fn blockType<"primary_expression">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo noting
 */
function	blockType<"primary_expression">(block : node)
{
  return (clearString(block.value));
}

/**
 * @fn blockType<"index_expression">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo nothing
 */
function	blockType<"index_expression">(block : node)
{
  return (blockType<block.left.type>(block.left)
	  + '[' + loopBlock(block.right) + ']');
}

/**
 * @fn blockType<"constant_expression">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo noting
 */
function	blockType<"constant_expression">(block : node)
{
  return (blockType<"primary_expression">(block));
}

/**
 * @fn blockType<"if">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo noting
 */
function	blockType<"if">(block : node)
{
  local		sInfo;

  sInfo = "if ("
    + blockType<block.condition.type>(block.condition)
    + ")";
  if (existVariable(block.then.otype))
    sInfo += "\n{\n" + blockType<block.then.otype>(block.then) + "}\n";
  else
    sInfo += ';';
  if (existVariable(block.else))
    sInfo += "else\n{\n" + loopBlock(block.else) + "}\n";
  return (sInfo);
}

/**
 * @fn blockType<"equality_expression">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo noting
 */
function	blockType<"equality_expression">(block : node)
{
  local		sInfo = "";

  if (existVariable(block.left.type))
    sInfo += blockType<block.left.type>(block.left) + ' ';
  if (existVariable(block.operator))
    sInfo += block.operator;
  if (existVariable(block.right.type))
    sInfo += ' ' + blockType<block.right.type>(block.right);
  sInfo += endPoint(block);
  return (sInfo);
}

/**
 * @fn blockType<"relational_expression">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo noting
 */
function	blockType<"relational_expression">(block : node)
{
  return (blockType<"equality_expression">(block));
}

/**
 * @fn blockType<"logical_and_expression">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo noting
 */
function	blockType<"logical_and_expression">(block : node)
{
  return (blockType<"equality_expression">(block));
}

/**
 * @fn blockType<"logical_or_expression">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo noting
 */
function	blockType<"logical_or_expression">(block : node)
{
  return (blockType<"equality_expression">(block));
}

/**
 * @fn blockType<"then">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo noting
 */
function	blockType<"then">(block : node)
{
  return (loopBlock(block.block));
}

/**
 * @fn blockType<"additive_expression">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo noting
 */
function	blockType<"additive_expression">(block : node)
{
  return (blockType<"equality_expression">(block));
}

/**
 * @fn blockType<"multiplicative_expression">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo noting
 */
function	blockType<"multiplicative_expression">(block : node)
{
  return (blockType<"equality_expression">(block));
}

/**
 * @fn blockType<"coma_expression">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo noting
 */
function	blockType<"coma_expression">(block : node)
{
  return (blockType<"equality_expression">(block));
}

/**
 * @fn blockType<"postfix_expression">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo noting
 */
function	blockType<"postfix_expression">(block : node)
{
  return (blockType<"equality_expression">(block));
}

/**
 * @fn blockType<"unary_expression">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo noting
 */
function	blockType<"unary_expression">(block : node)
{
  local		sInfo = "";

  if (existVariable(block.operator))
    sInfo += block.operator;
  if (existVariable(block.left))
    sInfo += ' ' + blockType<block.left.type>(block.left);
  if (existVariable(block.right))
    sInfo += ' ' + blockType<block.right.type>(block.right);
  return (sInfo);
}

/**
 * @fn blockType<"prefix_expression">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo noting
 */
function	blockType<"prefix_expression">(block : node)
{
  return (blockType<"unary_expression">(block));
}

/**
 * @fn blockType<"call_expression">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo noting
 */
function	blockType<"call_expression">(block : node)
{
  local		sInfo;

  sInfo = blockType<block.left.type>(block.left)
    + '(';
  if (existVariable(block.list))
    sInfo += loopArgument(block.list);
  sInfo += ')' + endPoint(block);
  return (sInfo);
}

/**
 * @fn blockType<"assignement_expression">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo noting
 */
function	blockType<"assignement_expression">(block : node)
{
  return (blockType<"additive_expression">(block));
}

/**
 * @fn blockType<"while">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo noting
 */
function	blockType<"while">(block : node)
{
  local		sInfo;

  sInfo = "while ("
    + blockType<block.condition.type>(block.condition)
    + ")\n{\n"
    + blockType<"stmt">(block.stmt)
    + "}\n";
  return (sInfo);
}

/**
 * @fn blockType<"stmt">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo noting
 */
function	blockType<"stmt">(block : node)
{
  return (loopBlock(block.block));
}

/**
 * @fn blockType<"for">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo noting
 */
function	blockType<"for">(block : node)
{
  local		sInfo;

  sInfo = "for ("
    + blockType<"init">(block.init) + "; "
    + blockType<block.condition.type>(block.condition) + "; "
    + blockType<block.increment.type>(block.increment)
    + ")\n{\n"
    + blockType<"stmt">(block.stmt)
    + "}\n";
  return (sInfo);
}

/**
 * @fn blockType<"init">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo noting
 */
function	blockType<"init">(block : node)
{
  return (loopBlock(block));
}

/**
 * @fn blockType<"switch">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo noting
 */
function	blockType<"switch">(block : node)
{
  return ("switch ("
	  + blockType<block.condition.type>(block.condition)
	  + ")\n{\n"
	  + loopBlock(block.block)
	  + "}\n");
}

/**
 * @fn blockType<"case">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo noting
 */
function	blockType<"case">(block : node)
{
  return ("case " + blockType<block.case.type>(block.case) + ":\n"
	  + loopBlock(block.block));
}

/**
 * @fn blockType<"default">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo noting
 */
function	blockType<"default">(block : node)
{
  return ("default:\n" + loopBlock(block.block));
}

/**
 * @fn blockType<"break">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo noting
 */
function	blockType<"break">(block : node)
{
  return ("break;\n");
}

/**
 * @fn blockType<"conditional_expression">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo noting
 */
function	blockType<"conditional_expression">(block : node)
{
  return (blockType<block.condition.type>(block.condition)
	  + ' ' + block.operator + ' '
	  + blockType<block.then.type>(block.then)
	  + " : " + blockType<block.else.type>(block.else));
}

/**
 * @fn blockType<"sizeof_expression">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo noting
 */
function	blockType<"sizeof_expression">(block : node)
{
  return (blockType<"unary_expression">(block));
}

/**
 * @fn blockType<"deref_expression">(block : node)
 * @brief nothing
 * @param block tree's block
 * @return sInfo noting
 */
function	blockType<"deref_expression">(block : node)
{
  return (blockType<"equality_expression">(block));
}

/**
 * @fn prettyPrintExistFile(file : value, block : node);
 * @brief use this function if you want prettyPrint a exist file
 * @param file filename
 * @param block tree'block source
 */
function	prettyPrintExistFile(file : value, block : node)
{
  local		sInfo = "";

  if (this.kooc.stack["pathC"].existFile())
    sInfo = loadFile(file);
  insert block.noheader = 0;
  generate("./mod.h.cwt", block, file);
  sInfo += loadFile(file);
  generate("./mod.c.cwt", block, file);
  sInfo += loadFile(file);
  saveToFile(file, sInfo);
  indentFile(file, "C++");
}
