/**
 * @file koocClass.inc.cws
 * @brief koocClass functions
 * @note @ref develop @ref contrib @ref tools
 */

declare function	koocClassDeclaration(sClass : value);
declare function	koocClassInit(sClass : value);
declare function	koocClassFill(sClass : value, sExtend : value);
declare function	koocClassInitVtable(sClass : value, sExtend : value);
declare function	koocClassExtend(sClass : value, sExtend : value, theNode : node);
declare function	koocClassErr(theNode : node);
declare function	koocClassAdd(sClass : value);
declare function	koocClassPrint(sClass : value);
declare function	koocClassExtendErr(sExtend : value);


function	koocClassDeclaration(sClass : value)
{
  localref	theBlock = this.block#back;
  local		isSelf = (theBlock.ctype.list#front.identifier == sClass &&
			  existVariable(theBlock.ctype.list#front.pointer) &&
			  theBlock.ctype.list#front.pointer.getArraySize() == 1);

  if (!isSelf)
    {
      insert theBlock.ctype.infoType;
      insert theBlock.ctype.infoType["static"]
	= "storageClassSpecifier";
    }
  if (this.block#back.type == "__VARIABLE__")
    treeInsertFileOut(getEnv("path_import")
		      + this.kooc.classes[sClass].nameH + "_variable",
		      theBlock);
  else
    treeInsertFileOut(getEnv("path_import")
		      + this.kooc.classes[sClass].nameH,
		      theBlock);
}

/**
 * @fn function	koocClassInit(sClass : value)
 * @brief init the tree'information to insert module
 * @param sClass module's name
 */
function	koocClassInit(sClass : value)
{
  local		modH = "kc_" + replaceString('.', '_', sClass.toLowerString()) + ".h";
  local		modC = "kc_" + replaceString('.', '_', sClass.toLowerString()) + ".c";

  insert this.kooc.classes[sClass];
  insert this.kooc.classes[sClass].nameH = modH;
  insert this.kooc.classes[sClass].nameC = modC;
}

function	koocClassInitVtable(sClass : value, sExtend : value)
{
  local decl;
  local name;
  local ctype;

  insert ctype.pctx;
  ref ctype.pctx = this.gl_pctx;

  insert ctype.type = "__COMPOSED__";
  insert ctype.identifier = "vt_" + sClass + "_s";
  insert ctype.specifier = "struct";
  insert ctype.list;

  if (existVariable(this.block.types[sExtend]))
  {
    localref rExt = this.block.types[sExtend];

    merge ctype.list = rExt.ctype.list;
  }

  cnormCreateDeclarationNode(decl, "__TYPE__");

  name = "vt_" + sClass + "_t";
  cnormFillDeclarationNode(decl, "__NAME__", name);
  cnormFillDeclarationNode(decl, "__CTYPE__", ctype);

  pushItem this.block;
  setall this.block#back = decl;

  ref this.block.types[name] = this.block#back;
}

function	koocClassFill(sClass : value, sExtend : value)
{
  local		ctype;

  insert ctype.pctx;
  ref ctype.pctx = this.gl_pctx;
  insert ctype.type = "__COMPOSED__";
  insert ctype.identifier = "kc_" + sClass.toLowerString();
  insert ctype.infoType;
  insert ctype.infoType["typedef"] = "storageClassSpecifier";
  insert ctype.specifier = "struct";
  insert ctype.list;
  pushItem this.block;
  treeInsertFileOut(getEnv("path_import")
		    + this.kooc.classes[sClass].nameH,
		    this.block#back);
  insert this.block#back.name = sClass;
  insert this.block#back.type = "__TYPE__";
  insert this.block#back.etype = "declaration";
  setall this.block#back.ctype = ctype;
  insert this.block.types[sClass];
  ref this.block.types[sClass] = this.block#back;
  if (sExtend)
    koocClassExtend(sClass, sExtend, this.block#back.ctype.list);
}

function	koocClassExtend(sClass : value, sExtend : value, theNode : node)
{
  local		ctype;

  insert ctype.pctx;
  ref ctype.pctx = this.gl_pctx;
  insert ctype.type = "__COMPOSED__";
  insert ctype.identifier = sExtend;
  pushItem theNode;
  treeInsertFileOut(getEnv("path_import")
		    + this.kooc.classes[sClass].nameH,
		    theNode#back);
  setall theNode#back.ctype = ctype;
  insert theNode#back.type = "__VARIABLE__";
  insert theNode#back.etype = "declaration";
  insert theNode#back.name = "parent";
}

function	koocClassErr(theNode : node)
{
  if (theNode.type == "__VARIABLE__" &&
      theNode.type == "__PROTOTYPE__")
    {
      traceLine("\"" + theNode.name + "\" is a incorrect declaration in @class");
      exit(-1);
    }
}

function	koocClassAdd(sClass : value)
{
  localref	theDecl = this.block#back;

  pushItem this.kooc.classes[sClass];
  ref this.kooc.classes[sClass]#back = this.block#back;
  if (theDecl.type == "__VARIABLE__")
    treeInsertFileOut(getEnv("path_import")
		      + this.kooc.classes[sClass].nameH + "_variable",
		      theDecl);
  else
    treeInsertFileOut(getEnv("path_import")
		      + this.kooc.classes[sClass].nameH,
		      theDecl);
}

function	koocClassPrint(sClass : value)
{
  koocImportIfndef(this.kooc.classes[sClass].nameH);
  {@@prettyPrinterToH(getEnv("path_import")
		      + this.kooc.classes[sClass].nameH + "_variable")@@}
  {@@prettyPrinterToC(getEnv("path_import")
		      + this.kooc.classes[sClass].nameH)@@}
  koocImportEndif(this.kooc.classes[sClass].nameH);
  indentFile(getEnv("path_import") + this.kooc.classes[sClass].nameH, "C++");
  setall this.kooc.classes[sClass].kooc.mangle = this.kooc.mangle;
}

function	koocClassExtendErr(sExtend : value)
{
  if (existClass(sExtend) == 0)
    {
      traceLine("Class " + sExtend + " doesn't exist");
      exit(-1);
    }
}
