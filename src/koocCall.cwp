/**
 * @file koocCall.cwp
 * @brief [ ... ] Kooc Expression file
 * @note @ref develop @ref contrib @ref tools
 *
 * @par primary_expression(expr : node)
 * rule (overload of Cnorm)
 *
 * @par koocCall
 * nothing
 *
 * @par cast : value
 * nothing
 *
 * @par kooc_identifiant_module(name : node, type_name : value)
 * nothing
 *
 * @par kooc_identifiant_variable(module_name : value, type : value)
 * nothing
 *
 * @par kooc_identifiant_fonction(module_name : value, func_name : node, type : value, nb_arg : node)
 * nothing
 *
 * @par kooc_list_parametre(module : value, func : value, nb_arg : value)
 * nothing
 *
 * @par kooc_identifier
 * nothing
 * 
 * @par kooc_param
 * nothing
 *
 */

/**
 * @cond
 */
#overload primary_expression(expr : node) ::=
#super::primary_expression(expr)
| koocCall(expr)
;

koocCall(expr : node) ::=
  => local module_name = "";
  => local type_name = "";
  => local func_name = "";
  => local nb_arg = "";
#explicitCopy [cast(expr):type_name]?
'['
kooc_identifiant_module(expr, module_name, type_name)
[
    kooc_identifiant_variable(expr, module_name, type_name)
 |
  [
    kooc_identifiant_fonction(expr, module_name, func_name, type_name, nb_arg)
    kooc_list_parametre(expr, module_name, func_name, nb_arg)
  ]
]
']'
;

cast(expr : node) : value ::= "@!("->(:cast)')'
;

kooc_identifiant_module(expr : node, module_name : node, type_name : value)
	   ::= [kooc_identifier ['.' kooc_identifier]*]:module_name
;

kooc_identifiant_variable(expr : node, module_name : node, type_name : node) ::=
	       [ !!']' // C'est une variable qui est demande
	       => { local val = "";
	       	    local name = module_name;
	       	    module_name = midString(name, 0, findLastString(name, '.'));
		    val = subString(name, $findLastString(name, '.') + 1$);
		    if (module_name != "self" && !existModule(module_name))
	       	      {
			 traceLine("error - module " + name + " doesn't exist.");
			 exit(-1);
		      }
		    if (module_name == "self")
		      {
		        existVar(this.kooc.stack["class"], val, type_name);
			insert expr.left;
			  insert expr.left.type = "primary_expression";
			  insert expr.left.value = "self";
			  insert expr.left.operator = "id";
			  insert expr.left.otype = "terminal";
			  insert expr.left.type = "primary_expression";
			insert expr.type = "deref_expression";
			insert expr.otype = "likebinary";
			insert expr.etype = "expression";
			insert expr.right;
			  insert expr.right.type = "primary_expression";
			  insert expr.right.value = val;
			  insert expr.right.operator = "id";
			  insert expr.right.otype = "terminal";
			insert expr.operator = "-&gt;";
		      }
		    else
		      {
		        local variable;
	   	    	variable = existVar(module_name, val, type_name);
	   	    	insert expr.value = variable;
	   	    	insert expr.operator = "id";
	   	    	insert expr.otype = "terminal";
		      }
		  }
	       ]
;

kooc_identifiant_fonction(expr : node, module_name : value, func_name : node, type : value, nb_arg : node)
::= 
  => {  if (!existModule(module_name))
        {
	  traceLine("error - module " + module_name + " doesn't exist.");
	  exit(-1);
	}
      }
  => local name = "";
  kooc_identifier:func_name
  => local func = existFunc(module_name, func_name, type, nb_arg);
  => insert expr.left;
  => insert expr.left.type = "primary_expression";
  => insert expr.left.value = func;
  => insert expr.left.operator = "id";
  => insert expr.left.otype = "terminal";
  => insert expr.left.etype = "expression";
  => insert expr.type = "call_expression";
  => insert expr.otype = "call";
  => insert expr.operator = "()";
  => insert expr.list;
;

kooc_list_parametre(expr : node, module : value, func : value, nb_arg : value)
     ::=
     => local i = 0;
     [
      ':' kooc_param(expr):val
      => i = $i + 1$;
      ]*
     => { if (nb_arg > i)
	 {
	   traceLine("error - function " + func + " not enouch param in argument (need " + nb_arg + " arg,  you give " + i + " arg)");
	   exit(-1);
	 }
	  if (nb_arg < i)
	    {
	      traceLine("error - function " + func + " too many param in argument (need " + nb_arg + " arg,  you give " + i + " arg)");
	      exit(-1);
	    }
     }
;

kooc_identifier ::= #readIdentifier
;

kooc_param(expr : node) ::=
  => pushItem expr.list;
  => insert expr.list#back.type = "primary_expression";
   [
   #readIdentifier:val | #readNumeric:val
   => insert expr.list#back.value = val;
   => insert expr.list#back.operator = "id";
   => insert expr.list#back.otype = "terminal";
   ]
  | [
      [
      #readCString:val
      => insert expr.list#back.value = '"' + val + '"';
      => insert expr.list#back.ctype;
      => insert expr.list#back.ctype.identifier = "char";
      => insert expr.list#back.infotype;
      => insert expr.list#back.infotype["const"] = "typeQualifier";
      => insert expr.list#back.pointer;
      => insert expr.list#back.pointer["0"];
      => insert expr.list#back.pointer["0"].level = "*";
      ]
    | [
      #readCChar:val
      => insert expr.list#back.value = "'" + val + "'";
      => insert expr.list#back.ctype;
      => insert expr.list#back.ctype.identifier = "char";
      ]
    => insert expr.list#back.otype = "terminal";
    => insert expr.list#back.operator = "literal";
    ]
;
/**
 * @endcond
 */
