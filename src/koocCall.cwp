/**
 * @file koocCall.cwp
 * @brief [ ... ] Kooc Expression file
 * @note @ref develop @ref contrib @ref tools
 *
 * @par primary_expression(expr : node)
 * rule (overload of Cnorm)
 *
 * @par koocCall
 * nothing
 *
 * @par cast : value
 * nothing
 *
 * @par kooc_identifiant_module(name : node)
 * nothing
 *
 * @par kooc_identifiant_variable(module_name : value, type : value)
 * nothing
 *
 * @par kooc_identifiant_fonction(module_name : value, func_name : node, type : value, nb_arg : node)
 * nothing
 *
 * @par kooc_list_parametre(module : value, func : value, nb_arg : value)
 * nothing
 *
 * @par kooc_identifier
 * nothing
 * 
 * @par kooc_param
 * nothing
 *
 */

/**
 * @cond
 */
#overload primary_expression(expr : node) ::=
#super::primary_expression(expr)
| koocCall(expr)
;

koocCall(expr : node) ::=
  => local module_name = "";
=> local func_name = "";
=> local type_name = "";
=> local nb_arg = 0;
#explicitCopy [cast:type_name]?
'['
kooc_identifiant_module(module_name)
[kooc_identifiant_variable(expr, module_name, type_name)
 | [kooc_identifiant_fonction(expr, module_name, func_name, type_name, nb_arg)
    kooc_list_parametre(expr, module_name, func_name, nb_arg)]]
']'
;

cast : value ::= "@!("->(:cast)')'
	     ;

kooc_identifiant_module(name : node)
	   ::= kooc_identifier:name// ['.' kooc_identifier]*]:name
	     => existModule(name);
;

kooc_identifiant_variable(expr : node, module_name : value, type : value)
	   ::= '.' kooc_identifier:val
	   => local variable;
	   => variable = existVar(module_name, val, type);
	   => insert expr.value = variable;
	   => insert expr.operator = "id";
	   => insert expr.otype = "terminal";
;

kooc_identifiant_fonction(expr : node, module_name : value, func_name : node, type : value, nb_arg : node)
::= kooc_identifier:func_name
  => local func = existFunc(module_name, func_name, type, nb_arg);
//=> { %>@func@(<% }
=> insert expr.left;
=> insert expr.left.type = "primary_expression";
=> insert expr.left.value = func;
=> insert expr.left.operator = "id";
=> insert expr.left.otype = "terminal";
=> insert expr.left.etype = "expression";
=> insert expr.type = "call_expression";
=> insert expr.otype = "call";
=> insert expr.operator = "()";
=> insert expr.list;
;

kooc_list_parametre(expr : node, module : value, func : value, nb_arg : value)
     ::=
     => local i = 0;
     [
      ':' kooc_param(expr):val
      => i = $i + 1$;
      ]*
     => { if (nb_arg > i)
	 {
	   traceLine("error - function " + func + " not enouch param in argument (need " + nb_arg + " arg,  you give " + i + " arg)");
	   exit(-1);
	 }
	  if (nb_arg < i)
	    {
	      traceLine("error - function " + func + " too many param in argument (need " + nb_arg + " arg,  you give " + i + " arg)");
	      exit(-1);
	    }
     }
;

kooc_identifier ::= #readIdentifier
;

kooc_param(expr : node) ::=
  => pushItem expr.list;
  => insert expr.list#back.type = "primary_expression";
   [
   #readIdentifier:val | #readNumeric:val
   => insert expr.list#back.value = val;
   => insert expr.list#back.operator = "id";
   => insert expr.list#back.otype = "terminal";
   ]
  | [
      [
      #readCString:val
      => insert expr.list#back.value = '"' + val + '"';
      => insert expr.list#back.ctype;
      => insert expr.list#back.ctype.identifier = "char";
      => insert expr.list#back.infotype;
      => insert expr.list#back.infotype["const"] = "typeQualifier";
      => insert expr.list#back.pointer;
      => insert expr.list#back.pointer["0"];
      => insert expr.list#back.pointer["0"].level = "*";
      ]
    | [
      #readCChar:val
      => insert expr.list#back.value = "'" + val + "'";
      => insert expr.list#back.ctype;
      => insert expr.list#back.ctype.identifier = "char";
      ]
    => insert expr.list#back.otype = "terminal";
    => insert expr.list#back.operator = "literal";
    ]
;
/**
 * @endcond
 */
