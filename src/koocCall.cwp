/**
 * @file koocCall.cwp
 * @brief [ ... ] Kooc Expression file
 * @note @ref develop @ref contrib @ref tools
 *
 * @par primary_expression(expr : node)
 * rule (overload of Cnorm)
 *
 * @par koocCall
 * nothing
 *
 * @par cast : value
 * nothing
 *
 * @par kooc_identifiant_module(name : node, type_name : value)
 * nothing
 *
 * @par kooc_identifiant_variable(module_name : value, type : value)
 * nothing
 *
 * @par kooc_identifiant_fonction(module_name : value, func_name : node, type : value, nb_arg : node)
 * nothing
 *
 * @par kooc_list_parametre(module : value, func : value, nb_arg : value)
 * nothing
 *
 * @par kooc_identifier
 * nothing
 * 
 * @par kooc_param
 * nothing
 *
 */

/**
 * @cond
 */
#overload primary_expression(expr : node) ::=
#super::primary_expression(expr)
| koocCall(expr)
;

koocCall(expr : node) ::=
  => local module_name = "";
=> local type_name = "";
#explicitCopy [cast:type_name]?
'['
kooc_identifiant_module(expr, module_name, type_name)
']'
;

cast : value ::= "@!("->(:cast)')'
	     ;

kooc_identifiant_module(expr : node, module_name : node, type_name : value)
	   ::= [kooc_identifier ['.' kooc_identifier]*]:name
	       [ !!']' // C'est une variable qui est demande
	       => { local val = "";
	       	    module_name = midString(name, 0, findLastString(name, '.'));
		    val = subString(name, $findLastString(name, '.') + 1$);
		    if (!existModule(module_name))
	       	       {
			 traceLine("error - module " + name + " doesn't exist.");
			 exit(-1);
		       }
		    local variable;
	   	    variable = existVar(module_name, val, type_name);
	   	    insert expr.value = variable;
	   	    insert expr.operator = "id";
	   	    insert expr.otype = "terminal";
		  }
	       ] | // C'est un appel de fonction
	       [ kooc_identifier:name
	       	 => local func_name = "";
	       	 => local nb_arg = 0;
		 => {  if (!existModule(name))
	       	       {
			 traceLine("error - module " + name + " doesn't exist.");
			 exit(-1);
		       }
		     }
	       kooc_identifiant_fonction(expr, name, func_name, type_name, nb_arg)
    	       kooc_list_parametre(expr, module_name, func_name, nb_arg) ]
;

kooc_identifiant_fonction(expr : node, module_name : value, func_name : node, type : value, nb_arg : node)
::= kooc_identifier:func_name
  => local func = existFunc(module_name, func_name, type, nb_arg);
//=> { %>@func@(<% }
=> insert expr.left;
=> insert expr.left.type = "primary_expression";
=> insert expr.left.value = func;
=> insert expr.left.operator = "id";
=> insert expr.left.otype = "terminal";
=> insert expr.left.etype = "expression";
=> insert expr.type = "call_expression";
=> insert expr.otype = "call";
=> insert expr.operator = "()";
=> insert expr.list;
;

kooc_list_parametre(expr : node, module : value, func : value, nb_arg : value)
     ::=
     => local i = 0;
     [
      ':' kooc_param(expr):val
      => i = $i + 1$;
      ]*
     => { if (nb_arg > i)
	 {
	   traceLine("error - function " + func + " not enouch param in argument (need " + nb_arg + " arg,  you give " + i + " arg)");
	   exit(-1);
	 }
	  if (nb_arg < i)
	    {
	      traceLine("error - function " + func + " too many param in argument (need " + nb_arg + " arg,  you give " + i + " arg)");
	      exit(-1);
	    }
     }
;

kooc_identifier ::= #readIdentifier
;

kooc_param(expr : node) ::=
  => pushItem expr.list;
  => insert expr.list#back.type = "primary_expression";
   [
   #readIdentifier:val | #readNumeric:val
   => insert expr.list#back.value = val;
   => insert expr.list#back.operator = "id";
   => insert expr.list#back.otype = "terminal";
   ]
  | [
      [
      #readCString:val
      => insert expr.list#back.value = '"' + val + '"';
      => insert expr.list#back.ctype;
      => insert expr.list#back.ctype.identifier = "char";
      => insert expr.list#back.infotype;
      => insert expr.list#back.infotype["const"] = "typeQualifier";
      => insert expr.list#back.pointer;
      => insert expr.list#back.pointer["0"];
      => insert expr.list#back.pointer["0"].level = "*";
      ]
    | [
      #readCChar:val
      => insert expr.list#back.value = "'" + val + "'";
      => insert expr.list#back.ctype;
      => insert expr.list#back.ctype.identifier = "char";
      ]
    => insert expr.list#back.otype = "terminal";
    => insert expr.list#back.operator = "literal";
    ]
;
/**
 * @endcond
 */
