/**
 * @file koocImplementation.inc.cws
 * @brief koocImplementation functions
 * @note @ref develop @ref contrib @ref tools
 * @todo signaler error lorsqu'une fonction
 * definis dans \@imnplementation
 * n'est pas defini dans \@module
 * @todo mangling des definitions de fonctions.
 */

declare function	koocImplementationInit(sName : value, type : node, filenameC : node);
declare function	koocImplementationContent(sName : value, type : value);
declare function	koocImplementationPrint(sName : value, type : value);
declare function	koocImplementationErr();
declare function	koocImplementationAdd(sName : value, type : value);
declare function	koocImplementationCheck();
declare function	koocImplementationDependency(sName : value, theImplementation : node);
declare function	check_implementation(name : value, theNode : node);
declare function	check_prototypes(var1 : node, var2 : node);
declare function	check_arguments(fun1 : node, fun2 : node);

/**
 * @fn koocImplementationInit(sName : value, type : node, filenameC : node)
 * @brief undef
 * @param sName value
 * @param type node
 * @param filenameC node
 */
function	koocImplementationInit(sName : value, type : node, filenameC : node)
{
  if (existModule(sName) == 1)
    {
      type = "module";
      filenameC = this.kooc.modules[sName].nameC;
    }
  else if (existClass(sName) == 1)
    {
      type = "class";
      filenameC = this.kooc.classes[sName].nameC;
    }
  else
    {
      traceLine("Module or Class [" + sName + "] doesn't exist");
      exit(-1);
    }
}

/**
 * @fn koocImplementationContent(sName : value, type : value)
 * @brief undef
 * @param sName value
 * @param type value
 */
function	koocImplementationContent(sName : value, type : value)
{
  koocImplementationErr();
  koocImplementationAdd(sName, type);
}

/**
 * @fn koocImplementationPrint(sName : value, type : value)
 * @brief undef
 * @param sName value
 * @param type value
 */
function	koocImplementationPrint(sName : value, type : value)
{
  local		sFile;

  if (type == "module")
    {
      koocImportInclude(this.kooc.modules[sName].nameH);
      check_implementation(sName, this.kooc.modules);
      {@@prettyPrinterToC(getEnv("path_import")
			  + this.kooc.modules[sName].nameH + "_variable")@@}
      {@@prettyPrinterToC(getEnv("path_import")
			  + this.kooc.modules[sName].nameC)@@}
    }
  else if (type == "class")
    {
      koocImportInclude(this.kooc.classes[sName].nameH);
      check_implementation(sName, this.kooc.classes);
      {@@prettyPrinterToC(getEnv("path_import")
			  + this.kooc.classes[sName].nameC)@@}
      sFile = getEnv("path_import")
	+ replaceString(".c", ".meta.c", this.kooc.classes[sName].nameC);
      generate("meta.c.cwt", this, sFile);
      indentFile(sFile, "C++");
      sFile = getEnv("path_import")
	+ replaceString(".h", ".meta.h", this.kooc.classes[sName].nameH);
      generate("meta.h.cwt", this, sFile);
      indentFile(sFile, "C++");
    }
}

/**
 * @fn koocImplementationErr()
 * @brief undef
 */
function	koocImplementationErr()
{
  localref	theNode = this.block#back;

  if (theNode.type != "__FUNCTION__")
    {
      traceLine("\"" + theNode.name + "\" is a incorrect declaration in @implementation");
      exit(-1);
    }
}

/**
 * @fn koocImplementationAdd(sName : value, type : value)
 * @brief undef
 * @param sName value
 * @param type value
 */
function	koocImplementationAdd(sName : value, type : value)
{
  pushItem this.kooc.implementations[sName];
  localref theImplementation = this.kooc.implementations[sName];
  ref theImplementation#back = this.block#back;
  localref theNode = theImplementation#back;
  localref theDecl = this.block#back;
  if (type == "module")
    treeInsertFileOut(getEnv("path_import")
		      + this.kooc.modules[sName].nameC,
		      theDecl);
  else if (type == "class")
    {
      treeCreateOneNew(theDecl, "__PROTOTYPE__", theImplementation);
      treeInsertFileOut(getEnv("path_import")
			+ this.kooc.classes[sName].nameC,
			theDecl);
    }
  treeAddSelf(sName, theDecl);
}

/**
 * @fn koocImplementationCheck()
 * @brief check if all functions defined have been implemented
 */
function	koocImplementationCheck()
{
  local		bool;
  local		err;

  foreach namePrototype in this.block.prototypes
  {
    bool = false;
    foreach nameFunction in this.block.functions
      if (key(namePrototype) == key(nameFunction))
	{
	  bool = true;
	  break;
	}
    if (bool == false)
      {
	local name = namePrototype.oname;
	local line = namePrototype.__LINE__;
	local file = namePrototype.__FILE__;
	traceLine("[KOOC] " + file + ": (line " + line + ") function [" + name + "] undeclared");
      }
  }
}

function	koocImplementationDependency(sName : value, theImplementation : node)
{
  treeCreateNew(sName, "__FUNCTION__", theImplementation);
  treeCreateClean(sName, "__FUNCTION__", theImplementation);
  treeInsertFileOut(this.kooc.classes[sName].nameC, this.block#back);
  ref this.block.functions[this.block#back.name] = this.block#back;
  treeCreateDelete(sName, "__FUNCTION__", theImplementation);
}

/**
 * @fn check_implementation(name : value, theNode : node)
 * @brief check if functions implemented have been great defined
 * in the good module
 * @param name (value): implentation's name
 * @param theNode node
 */
function	check_implementation(name : value, theNode : node)
{
  local		prototype;
  local		find;

  foreach item in theNode[name].block
  {
    if (item.type = "__PROTOTYPE__")
      {
	find = false;
	foreach itemImp in this.kooc.implementations[name].block
	{
	  if ((item.name == itemImp.name) &&
	      (check_prototypes(item, itemImp) == true))
	    {
	      find = true;
	      break;
	    }
	}
	if (find == false)
	  {
	    prototype = item.sign + " " + item.identifier;
	    prototype += " " + item.name + "(...)";
	    traceLine("error: [ " + prototype + " ]'s declaration is missing");
	  }
      }
  }
}

/**
 * @fn check_prototypes(var1 : node, var2 : node)
 * @brief check if both prototype are equal
 * @param var1 (node): node to first prototype
 * @param var2 (node): node to second prototype
 * @return true if ok otherwise false
 */
function	check_prototypes(var1 : node, var2 : node)
{
  local		args = "";

  if ((var2.ctype.identifier == var1.ctype.identifier)
      && (var2.ctype.sign == var1.ctype.sign)
      && (check_arguments(var1.list, var2.list) == true))
    return (true);
  return (false);
}

/**
 * @fn check_arguments(fun1 : node, fun2 : node)
 * @brief check if prototypes' arguments are equal
 * @param fun1 (node): node to first prototype
 * @param fun2 (node): node to second prototype
 * @return true if ok otherwise false
 */
function	check_arguments(fun1 : node, fun2 : node)
{
  local		argsFun1 = "";
  local		argsFun2 = "";

  if (countNbArgInFunc(fun1) != countNbArgInFunc(fun2))
    return (false);
  foreach info in fun1
    argsFun1 += "[" + info.ctype.identifier + info.ctype.sign + "]";
  foreach info in fun2
    argsFun2 += "[" + info.ctype.identifier + info.ctype.sign + "]";
  return (argsFun1 == argsFun2);
}
