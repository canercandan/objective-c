/**
 * @file koocImplementation.inc.cws
 * @brief koocImplementation functions
 * @note @ref develop @ref contrib @ref tools
 * @todo signaler error lorsqu'une fonction
 * definis dans \@imnplementation
 * n'est pas defini dans \@module
 * @todo mangling des definitions de fonctions.
 */

declare function	koocImplementationInit(sName : value, type : node, filenameC : node);
declare function	koocImplementationContent(sName : value, type : value);
declare function	koocImplementationPrint(sName : value, type : value);
declare function	koocImplementationErr();
declare function	koocImplementationAdd(sName : value, type : value);
declare function	koocImplementationCheck();
declare function	check_implementation(name : value, theNode : node);
declare function	check_prototypes(var1 : node, var2 : node);
declare function	check_arguments(fun1 : node, fun2 : node);

// Fonctions non finis: normal que vous comprenez pas tout...
// Implementation de base marche mais je fixe qlq trucs.

function	koocImplementationInit(sName : value, type : node, filenameC : node)
{
  if (existModule(sName) == 1)
    {
      type = "module";
      filenameC = this.kooc.modules[sName].nameC;
    }
  else if (existClass(sName) == 1)
    {
      type = "class";
      filenameC = this.kooc.classes[sName].nameC;
    }
  else
    {
      traceLine("Module or Class [" + sName + "] doesn't exist");
      exit(-1);
    }
}

function	koocImplementationContent(sName : value, type : value)
{
  koocImplementationErr();
  koocImplementationAdd(sName, type);
}

function	koocImplementationPrint(sName : value, type : value)
{
  local		sFile;

  if (type == "module")
    {
      koocImportInclude(this.kooc.modules[sName].nameH);
      check_implementation(sName, this.kooc.modules);
      {@@prettyPrinterToC(getEnv("path_import")
			  + this.kooc.modules[sName].nameH + "_variable")@@}
      {@@prettyPrinterToC(getEnv("path_import")
			  + this.kooc.modules[sName].nameC)@@}
    }
  else if (type == "class")
    {
      koocImportInclude(this.kooc.classes[sName].nameH);
      check_implementation(sName, this.kooc.classes);
      {@@prettyPrinterToC(getEnv("path_import")
			  + this.kooc.classes[sName].nameC)@@}
      sFile = getEnv("path_import")
	+ replaceString(".c", ".meta.c", this.kooc.classes[sName].nameC);
      generate("meta.c.cwt", this, sFile);
      indentFile(sFile, "C++");
      sFile = getEnv("path_import")
	+ replaceString(".h", ".meta.h", this.kooc.classes[sName].nameH);
      generate("meta.h.cwt", this.kooc.classes[sName], sFile);
      indentFile(sFile, "C++");
    }
}

function	koocImplementationErr()
{
  localref	theNode = this.block#back;

  if (theNode.type != "__FUNCTION__")
    {
      traceLine("\"" + theNode.name + "\" is a incorrect declaration in @implementation");
      exit(-1);
    }
}

function	koocImplementationCreateNew(sName : value, theDecl : node)
{
  if (theDecl.oname == "init")
    {
      pushItem this.block;
      localref theSrc = this.block#back;
      setall theSrc = theDecl;
      insert theSrc.init = theDecl.name;
      theSrc.name = replaceString("init", "new", theSrc.name);
      theSrc.oname = replaceString("init", "new", theSrc.oname);
      pushItem this.kooc.implementations[sName];
      ref this.kooc.implementations[sName]#back = theSrc;
    }
}

function	koocImplementationAdd(sName : value, type : value)
{
  pushItem	this.kooc.implementations[sName];
  ref		this.kooc.implementations[sName]#back = this.block#back;
  localref	theNode = this.kooc.implementations[sName]#back;
  localref	theDecl = this.block#back;

  if (type == "module")
    treeInsertFileOut(getEnv("path_import")
		      + this.kooc.modules[sName].nameC,
		      theDecl);
  else if (type == "class")
    {
      koocImplementationCreateNew(sName, theDecl);
      treeInsertFileOut(getEnv("path_import")
			+ this.kooc.classes[sName].nameC,
			theDecl);
    }
  koocMemberAddSelf(sName, theDecl);
}

/**
 * @fn koocImplementationCheck()
 * @brief check si toutes les fonctions definies on ete implementate
 */
function	koocImplementationCheck()
{
  local		bool;
  local		err;

  foreach namePrototype in this.block.prototypes
  {
    bool = false;
    foreach nameFunction in this.block.functions
    {
      if (key(namePrototype) == key(nameFunction))
	{
	  bool = true;
	  break;
	}
    }
    if (bool == false)
      {
	local name = namePrototype.oname;
	local line = namePrototype.__LINE__;
	local file = namePrototype.__FILE__;
	traceLine("[KOOC] " + file + ": (line " + line + ") function [" + name + "] undeclared");
	//	exit(-1);
      }
  }
}

/**
 * @fn check_implementation(name : value)
 * @brief check si les fonctions implementater ont bien ete defini
 * dans le module concerne
 * @param name (value): nom de l'implementation
 */
function	check_implementation(name : value, theNode : node)
{
  local		prototype;
  local		find;

  foreach item in theNode[name].block
  {
    if (item.type = "__PROTOTYPE__")
      {
	find = false;
	foreach itemImp in this.kooc.implementations[name].block
	{
	  if ((item.name == itemImp.name) &&
	      (check_prototypes(item, itemImp) == true))
	    {
	      find = true;
	      break;
	    }
	}
	if (find == false)
	  {
	    prototype = item.sign + " " + item.identifier;
	    prototype += " " + item.name + "(...)";
	    traceLine("error: [ " + prototype + " ]'s declaration is missing");
	    //	    exit(-1);
	  }
      }
  }
}

/**
 * @fn check_prototypes(var1 : node, var2 : node, name : value)
 * @brief verifie si 2 prototypes de fonctions sont egals
 * @param var1 (node): noeud du 1er prototype
 * @param var2 (node): noeud du 2nd prototype
 * @param name (value): nom manglee de la fonction
 * @return true si ok, false sinon :p
 */
function	check_prototypes(var1 : node, var2 : node)
{
  local		args = "";

  if ((var2.ctype.identifier == var1.ctype.identifier)
      && (var2.ctype.sign == var1.ctype.sign)
      && (check_arguments(var1.list, var2.list) == true))
    return (true);
  else
    return (false);
}

/**
 * @fn check_arguments(fun1 : node, fun2 : node)
 * @brief verifie si les arguments de 2 prototypes de fonctions sont egals
 * @param fun1 (node): noeud du 1er prototype
 * @param fun2 (node): noeud du 2nd prototype
 * @return true si ok, false sinon :p
 */
function	check_arguments(fun1 : node, fun2 : node)
{
  local		argsFun1 = "";
  local		argsFun2 = "";

  if (countNbArgInFunc(fun1) != countNbArgInFunc(fun2))
    return (false);
  foreach info in fun1
    argsFun1 += "[" + info.ctype.identifier + info.ctype.sign + "]";
  foreach info in fun2
    argsFun2 += "[" + info.ctype.identifier + info.ctype.sign + "]";
  if (argsFun1 == argsFun2)
    return (true);
  else
    return (false);
}
