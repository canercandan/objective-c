/*
** cnormDeclarations.cwp for
** "C normalise"
** 
** Authors:
**	Lionel Auroux
** Contributors:
**	Cedric Lemaire
**	David Giron
**	David Amsallem
**
** see cnorm.cwp for details
*/

//----------------------------------------------------------------------------
//                           D E C L A R A T I O N S
//----------------------------------------------------------------------------


/*
  Base des declarations
*/
//#trace
declaration(theBlock : node) ::=
';' // point virgule celibataire tout triste dans son coin
| [
	/* On cree un nouvel element dans la liste des blocks*/
	#pushItem(theBlock)

	/* On stocke le numero de la ligne courante */
	=> insert theBlock#back.__LINE__ = countInputLines();
[
/* macro assembleur de haut-niveau */
asm_expr:theBlock#back.asm
=> insert theBlock#back.otype = "asmexpr";
=> insert theBlock#back.etype = "expression";

| [ /* DECLARATION C NORMALE */
	/* On cree un element ctype pour stocker les infos de la declaration */
	=> local ctype;
	/* On cree un reference sur le contexte parent pour la recherche de type */
	=> insert ctype.pctx;
	=> ref ctype.pctx = this.gl_pctx;//theBlock;
	=> cnormCreateCtypeNode(ctype);

	/* pour cause d'ambiguite on oblige un type pour les fonctions donc C ansi uniquement */
	/* recuperation du type de la declaration*/
	[ declaration_specifier(ctype) 
	/*  | 
	  // quand il n'y a pas de type, on prends "int" par defaut
	  => local bHackNoType = false;
	  => {
	    if (ctype.identifier == "__UNDEF__" // pas d'info de type
		&& ctype.type == "__UNDEF__"
		&& isEmpty(theBlock.pctx)) // dans le contexte globale
	    {
	      bHackNoType = true;
	      cnormFillCtypeNode(ctype, "__TYPEID__", "int");
	    }
	  }
		#check(bHackNoType) */
	]+
	/* on normalize les types - {un}sign{ed} et int manquant */
	=> cnormToolTypeNormalizeCType(ctype);
	/* on copie les types C dans le noeud de l'arbre */
	=> cnormFillDeclarationNode(theBlock#back, "__CTYPE__", ctype);
	/* par defaut c'est une declaration*/
	=> cnormCreateDeclarationNode(theBlock#back, "__VARIABLE__");
	/* pour les typedefs on fait un test de coherence */
	=> cnormCheckTypeDeclaration(theBlock#back);
	/* 
	   apres un type il peut y avoir 1 ou n symbole de ce type.
	   un symbole peut etre variable, fonction ou pointeur de fonction.
	*/
	init_declarator(theBlock#back)
	/* On fait une copie de toutes les infos de type pour 
	   la liste de variable de meme type */
	=> local aType;
	=> {
	  setall aType.type = theBlock#back.type; 
	  setall aType.ctype = theBlock#back.ctype;
	  setall aType.etype = theBlock#back.etype;
	}
[ // uniquement si on est pas une declaration de fonction
	#check(!(theBlock#back.type == "__FUNCTION__" 
	  && existVariable(theBlock#back.block)))
	[ ',' 
		#pushItem(theBlock)/* on ajoute un element du meme type */
		=> setall theBlock#back = aType;
		init_declarator(theBlock#back) 
	]*
	/* fin d'une declaration */
	  ';'
| // dans le cas d'une fonction, on a rien apres
 => local empty;
]]]]
;

/*
  GNU C bloc assembleur de haut niveau
*/
asm_expr ::= 
#readIdentifier:{"asm","__asm","__asm__"} [#readIdentifier:{"volatile", "__volatile__", "__volatile"}]? 
	[
		'(' 
   		 => local subExp;
   		 /* le plus souvent expression contient des expressions asm */
   		 expression(subExp)  
   		')' ';'
	]
;

/*
  ici tous ce qu'on peut mettre a gauche d'une declaration en C
*/
declaration_specifier(theType : node) ::= 
	=> local sKey;
	[
		storage_class_specifier:sKey
		| type_qualifier:sKey
		| function_specifiers:sKey | windows_specifiers(sKey)
	]
	=> cnormFillCtypeNode(theType, "__INFOTYPE__", sKey);
	| type_specifier(theType)
    // TODO: a mettre qq part
	| #pushItem(theType.comment_prefix) /* GnuC extensions */ 
	  #readIdentifier:{"__extension__"}:theType.comment_prefix#back 
	| #pushItem(theType.comment_prefix) /* c99 */ attribute_decl:theType.comment_prefix#back
;

/*
  les classes de stockages permette de savoir ou sont stocke les symboles.
  -auto: sur la pile (par defaut)
  -register: dans un registre
  -static: le symbole est local
  -extern: le symbole est dans un autre fichier objet
  -__thread: extension GnuC pour stocker une variable dans la TLS 
  (Thread Local Storage)
*/
storage_class_specifier ::= 
	#readIdentifier:{"auto", "register", "typedef", "static", "extern",
			 /* GnuC */ "__thread"
	}
;

/*
  pour etre plus rigoureux on extrait le mot clef inline juste pour la 
  declaration de fonction.
  -inline: la fonction peut ne pas etre presente dans le fichier final
  mais 'inliner' au niveau de son appel
*/
function_specifiers ::= 
	#readIdentifier:{"inline",
	 /*gnuC*/ "__inline", "__inline__",
	 /* Windows */ "__forceinline"}
;

/*
  function_specifiers specifiques a windows
*/
windows_specifiers(sKey : node) ::= 
	#readIdentifier:{"__declspec"}:sKey
	[
		'('
			[
				#readIdentifier:{"dllimport"}
				| #readIdentifier:{"noreturn"}
				| #readIdentifier:{"deprecated"} ['(' -> ')']?
				| #readIdentifier:{"align"} '(' #readInteger ')'
			]
		')' // FIXME ajouter dans l'arbre
	]
;

/*
  base de la declaration des types
*/
type_specifier(theType : node) ::=
	prime_type(theType)
	| struct_or_union_specifier(theType)
	| enum_specifier(theType)
	| /* c99 */ typeof_expr(theType)
	| typedef_name(theType)
;

/*
  type primitif du C
*/
prime_type(theType : node) ::=
[
 /* ici on match les signes */
	#readIdentifier:{
	  "signed", 
	  "unsigned",
	  /* gcc */ "__signed__", "__unsigned__", "__signed"
	}:sKey
	=> cnormFillCtypeNode(theType, "__SIGN__", sKey);
]
| [
 /* ici on match les specifiers et les types primitifs */
	#readIdentifier:{
	  "short",
	  "long",
	  "void",
	  "char",
	  "int", 
	  "float",
	  "double",
	  /* c99 */ "__complex", "__complex__", "_Complex",
	  "_Imaginary",
	  "_Bool",
	  "__label__",
	  /* gnuC */
	  "__builtin_va_list",
	  /* Windows VC++ 6.0+ */
	  "__int8",
	  "__int16",
	  "__int32",
	  "__int64"
	}:sKey
	=> cnormFillCtypeNode(theType, "__TYPEID__", sKey);
]
;

/*
  c99 : on l'utilise a l'emplacement d'un type dans une
  declaration. le type retourner depend du type passer en parametre ou 
  d'une expression passer en paremetre.
*/
typeof_expr(theType : node) ::=
	#readIdentifier:{"typeof","__typeof","__typeof__"}
	'(' #continue
	[
	 type_name(theType)
	 => insert theType.etype += "typename";
	 => insert theType.type = "__TYPEOF__";
	 | expression(theType)
	 => insert theType.etype += "expression";
	 => insert theType.type = "__TYPEOF__";
	]
	')'
;

/*
  un qualificatif de type est juste un petit mot ayant une influence sur
  le comportement du compilateur face au symbole.
  - const: ne peut etre modifier, le symbole est dans une section particuliere
  dans le fichier objet
  - volatile: le compilateur va optimiser d'une certaine maniere les objets
  volatile.
*/
type_qualifier ::= #readIdentifier:{"const", "volatile", "__volatile", "__volatile__",
				    /* c99 */ "restrict",
				    "__const",
				    "__restrict",
					/* Windows */ "__w64", "__ptr32", "__ptr64"
					}
;

/*
  construction classique d'une structure ou d'une union
*/
struct_or_union_specifier(theType : node) ::=
	=> local sKey;
	#readIdentifier:{"struct", "union"}:sKey
	=> cnormFillCtypeNode(theType, "__TYPEID__", sKey);
	[
		windows_specifiers(sKey)
	]?
	[ 
		identifier:sId
		=> cnormFillCtypeNode(theType, "__TYPEID__", sId);
	]?
	[ 
		#insert(theType.list)
		struct_fields(theType.list)
	]?
;

/*
  les champs de la structure
*/
struct_fields(theList : node) ::= 
'{' [';' // standalone empty expression
     | #pushItem(theList) 
     struct_declaration(theList#back) 
]* '}'
;

/*
  ensuite le type peut contenir une valeur par defaut.
*/
init_declarator(theType : node) ::=
=> local bComposed = "notcomposed";
=> 
{
  // il n'y a pas forcement de declarator pour les structs et les enums
  if (theType.ctype.type == "__COMPOSED__" && 
      (theType.ctype.specifier == "enum" 
       || theType.ctype.specifier == "struct" 
       || theType.ctype.specifier == "union")
      )
  {	bComposed = "composed";}
  else 
  {	bComposed = "notcomposed";}
}
[
      // pour ce qui n'est pas struct/union/enum il y a forcement un declarator
      #check(bComposed == "composed") [declarator(theType)]?:sDecl
      => 
	{//s'il n'y a pas eu de declarator, la struct/union/enum est promo au role de type
	  if (sDecl == "")
	  {	theType.type = "__TYPE__";}
	}
      // pour le reste c'est obligatoire
      | declarator(theType)
]

	/* c99 attribut */
	[ #pushItem(theType.comment_suffix) attribute_decl:theType.comment_suffix#back ]*

	/* valeur par defaut? */
	['=' #continue initializer(theType.init) ]?

	=> // on reference toujours les variables 
	{
	  if (theType.type == "__VARIABLE__" && existVariable(theType.name))
	  {	ref theType#parent.variables[theType.name] = theType;}
	}
[ 	// est-ce un typedef
	#check(findElement("typedef", theType.ctype.infoType) == true)
	=> {
	  if (existVariable(theType#parent.types[theType.name]))
	  {traceLine(theType.name + ": type already defined");}
	  else
	  {ref theType#parent.types[theType.name] = theType;}
	}
	// est-ce un enum
	| #check(theType.type != "__PROTOTYPE__"
		 && theType.ctype.type == "__COMPOSED__"
		 && existVariable(theType.ctype.list) // type definie
		 && theType.ctype.specifier == "enum")
	=> ref theType#parent.enums[theType.ctype.identifier] = theType;

	// est-ce une structure 
	| #check(theType.type != "__PROTOTYPE__"
		 && theType.ctype.type == "__COMPOSED__" 
		 && existVariable(theType.ctype.list) // type definie
		 && theType.ctype.specifier == "struct")
	=> ref theType#parent.structs[theType.ctype.identifier] = theType;

	// est-ce une union
	| #check(theType.type != "__PROTOTYPE__"
		 && theType.ctype.type == "__COMPOSED__" 
		 && existVariable(theType.ctype.list) // type definie
		 && theType.ctype.specifier == "union")
	=> ref theType#parent.unions[theType.ctype.identifier] = theType;
	
	// est-ce un pointeur de fonction
	| #check(theType.ctype.type == "__PFUNCTION__")
	=> ref theType#parent.pfunctions[theType.name] = theType;

	// est-ce une fonction
	| #check(theType.type == "__PROTOTYPE__")
	[
	 /* 
	    on verifie en faisant un lookahead (lecture sans deplacement)
	    si on est bien dans le cas d'une declaration de fonction
	    ou dans le cas de son implementation.
	 */
	 !![',' | ';' | '='] // declaration
	 => ref theType#parent.prototypes[theType.name] = theType;
	 | #continue 
	  [ // implementation
	   => theType.type = "__FUNCTION__";
	   => insert theType.otype = "rootblock";
	   => ref theType#parent.functions[theType.name] = theType;
	   compound_statement(theType)
	  ]
	]

	// variable simple
	| #check(theType.type == "__VARIABLE__")

	|// forward declaration de struct,union,enum
	#check(theType.type == "__TYPE__"
	       && theType.ctype.type == "__COMPOSED__")
	=> ref theType#parent.forwards[theType.ctype.identifier] = theType;
]
;

/*
  c99 : les attributs permettent d'activer certain mecanisme du compilo C.
*/
// FIXME a mettre dans l'arbre
attribute_decl ::=
	#readIdentifier:{"__attribute", "__attribute__"}
	'(' '(' => local dummy;
	attribute_call_parameter_list(dummy)
	')' ')' 
	| #readIdentifier:{"asm", "__asm","__asm__"} '(' #readCString ')'
	| /* Windows */ [ #readIdentifier:{"__cdecl", "__stdcall", "__fastcall", "_fastcall"} ]
;

attribute_call_parameter_list(expr : node) ::= #pushItem(expr)
     [ assignment_expression(expr#back) | type_name(expr#back) ]
     [ ',' #continue
       => pushItem expr;
     [ assignment_expression(expr#back) | type_name(expr#back) ]
     ]*
;


/*
  comme declaration_specifier mais sans classe de stockage car uniquement
  dans les champs d'une structure, dans les typedefs, dans les casts.
*/
specifier_qualifier(theType : node) ::= 
	type_qualifier:sKey
	=> cnormFillCtypeNode(theType, "__INFOTYPE__", sKey);
	| type_specifier(theType)
     /// TODO: a mettre qq part
	| #pushItem(theType.comment_prefix) /* GnuC extensions */ #readIdentifier:{"__extension__"}:theType.comment_prefix#back
	| #pushItem(theType.comment_prefix) /* c99 */ attribute_decl:theType.comment_prefix#back
;

/*
  contient une declaration dans une structure.
  cas particulier d'une declaration.
*/
struct_declaration(theFields : node) ::=
	// meme algo qu'une declaration
	=> local ctype;
	// cree une reference sur le block parent (resolutions des typedefs)
	=> insert ctype.pctx;
	=> ref ctype.pctx = this.gl_pctx;
	=> cnormCreateCtypeNode(ctype);
	[ specifier_qualifier(ctype) ]+
	=> cnormToolTypeNormalizeCType(ctype);
	=> cnormFillDeclarationNode(theFields, "__CTYPE__", ctype);
	=> cnormCreateDeclarationNode(theFields, "__VARIABLE__");
	[ struct_declarator_list(theFields, ctype) ]
	';'
;

/*
  semblable a init_declarator pour une structure.
  liste separer par ',' entre les symboles.
*/
struct_declarator_list(theFields : node, ctype : node) ::=
	struct_declarator(theFields)
	[',' // recopie le type et le storage de la premiere declaration 
	 // pour chaque champs
		#pushItem(theFields#parent)
		=> cnormFillDeclarationNode(theFields#parent#back, "__CTYPE__", ctype);
		=> cnormCreateDeclarationNode(theFields#parent#back, "__VARIABLE__");
		struct_declarator(theFields#parent#back)
	]*
;

/*
  lecture d'un bitfield de structure, 
  optionel ou pas selon la presence ou non du declarator dans struct_declarator
*/
struct_bitfield(theType : node, notmandatory : value) ::=
=> local have_bitfield = false;
[ 
 ':' 
 // => traceLine("bitfield a " + countInputLines());
#continue constant_expression(theType.bits) 
 => theType.ctype.type = "__BITFIELD__";// switch to bitfield
 => have_bitfield = true;
]?
;

/*
  symboles dans une structure et gestion des champs de bits
*/
struct_declarator(theType : node) ::=
=> local have_declarator = false;
   [declarator(theType)]?
   // lecture du bitfield conditionne par la presence ou non du declarator
   struct_bitfield(theType, have_declarator)
   /* c99 attribut */
   [ #pushItem(theType.comment_suffix) attribute_decl:theType.comment_suffix#back ]*
;

/*
  construction d'un enum.
*/
enum_specifier(theType : node) ::= 
	#readIdentifier:{"enum"}:sKey
	=> cnormFillCtypeNode(theType, "__TYPEID__", sKey);
[ 
	identifier:sId
	=> cnormFillCtypeNode(theType, "__TYPEID__", sId);
]?
[ 
	'{' #continue 
	=> local theList;
	enumerator_list(theList)
	=> cnormFillDeclarationNode(theType, "__LIST__", theList);
	'}' 
]?
;

/*
  construction de la liste d'identifiant de l'enum.
*/
enumerator_list(theHash : node) ::=
	enumerator(theHash) 
     [ ',' #continue [ enumerator(theHash) ]? ]*
;

/*
  un identifiant de l'enum peut avoir une valeur par defaut.
*/
enumerator(theHash : node) ::= 
	identifier:sKey
	=> insert theHash[sKey];
	[ '=' #continue constant_expression(theHash[sKey].init) 
	  => insert theHash[sKey].init.etype = "init";
	  ]?
;

/*
  point central des declarations a la fois normal,typedef,struct,fonction.
*/
declarator(theType : node) ::=  [ pointer(theType) ]? 
	[#pushItem(theType.comment_prefix) /* c99 */ attribute_decl:theType.comment_prefix#back]* 
	absolute_declarator(theType)
;

/*
  absolute_declarator est une construction complexe permettant d'exprimer
  tous les cas d'expressions d'une declaration C.
  principalement pointeur de fonction, tableau etc...
*/
absolute_declarator(theType : node) ::= 
[
 => local sKey;
 [ 
  [// identifiant variable/fonction normale
   function_or_variable_identifier(theType, sKey)
   => cnormFillDeclarationNode(theType, "__NAME__", sKey);
  ]
  | [// pointeur de fonction     
   '(' 
	[// on fabrique une reference pour le cas
	 // du pointer optionel
	 => local option_ref;
	 => ref option_ref = theType;
	 [
	  // on copie tout dans la variable locale
	 => local nodecopy;
	 [#pushItem(theType.comment_prefix) /* c99 */ attribute_decl:theType.comment_prefix#back]?
	 pointer(nodecopy)
	 => 
	     {
	       //IOPI:
	       insert theType.pfname;
	       // c'est bien un pointer de fonction
	      foreach indirection in nodecopy.ctype.pointer
	      {
		// on recopie les niveaux de pointeurs comme des niveaux
		// de pointeurs de fonctions. le reste est inchange...
		//pushItem theType.ctype.pointer;
		pushItem theType.pfname;
		if (existVariable(indirection.level))
		//		{	insert theType.ctype.pointer#back.function;}
		{	insert theType.pfname#back.function;}
		else
		  //{	setall theType.ctype.pointer#back = indirection;}
		  {	setall theType.pfname#back = indirection;}
	      }
	       // la reference local pointe maintenant dans le pointer de fonction
	       ref option_ref = theType.pfname#back.function;
	    }
	 ]?
	 declarator(option_ref)
	 ]
   ')'
   ]
 ]
[
 /* ce qui suis est soit la definition du tableau, soit les parametres
    du pointeur de fonction, ou une fonction si l'identifiant n'est pas
    un pfunction
 */
  [ direct_absolute_declarator(theType) ]?
  => {
    // cas du pointer de fonction
    if (existVariable(theType.pfname#back.function))
    {
      if (!findElement("typedef", theType.ctype.infoType))
      {	insert theType.type = "__VARIABLE__";}
      else
      {	insert theType.type = "__TYPE__";}
      insert theType.ctype.type = "__PFUNCTION__";
      insert theType.name = theType.pfname#back.function.name;
    }
  }
 ]
]
;

function_or_variable_identifier(theType : node, theIdent : node) ::=
	/* symbole simple */
	identifier:theIdent
;

/*
  definition d'un tableau ou parametre de fonction
*/
direct_absolute_declarator(theType : node) ::=
[
	 /* tableau */
	'[' #continue

	/* c99 static in direct absolute declarator */
	  ["static"]?
	  [
	   type_qualifier:sKey
	  ]*
	  ["static"]?
	/* c99 end */
	=> local subExpr;
	 [
	  assignment_expression(subExpr)
	  | '*' // parse mais non gere
	 ]?:subExpr
	']'
	  => cnormFillCtypeNode(theType.ctype, "__ARRAY__", subExpr);
]+
| [ /* parametre de fonction */
   '(' #continue
   => local bPostDeclaration = false;
	#insert(theType.list)
	=> cnormCreateDeclarationNode(theType, "__PROTOTYPE__");
	[ 
	 /* style ANSI */ parameter_type_list(theType.list)
	 | /* style K&R */ kr_parameter_type_list(theType.list)
	 => bPostDeclaration = true;	 
	]?
   ')'
   [/* En K&R on a la declaration des types apres la ) fermante*/
    #check(bPostDeclaration)
    [ 
     => local nInfoParam;
     declaration(nInfoParam)
     => {
       local rParam; 
       // on cherche le bon param dans la liste
       if (cnormToolInArrayValues(nInfoParam#back.name, theType.list, rParam))
       {
	 // on recopie le noeud
	 setall rParam = nInfoParam#back;
       }
       // TODO: cas d'erreur
     }
    ]*
    ["..." #pushItem(theType.list) => insert theType.list#back.ellipsis = true; ]?
    |/* ANSI-C */
    => local empty;
    ]
]
;

/*
  sequence de symbole pointer separer par des qualificatifs de type 
  (const,volatile).
*/
pointer(theType : node) ::= 
	"*" => cnormFillCtypeNode(theType.ctype, "__POINTER__", "*");
	[ // intercalage d'un "const" ou "volatile" dans un niveau de pointeur
		type_qualifier:sKey
		=> cnormFillCtypeNode(theType.ctype, "__POINTER__", sKey);
	| // ou plusieurs niveau d'etoile	
		"*" => cnormFillCtypeNode(theType.ctype, "__POINTER__", "*");
	]*
;

// on stocke de maniere preliminaire dans la liste de parametre
kr_parameter_type_list(theFunction : node) ::=
=> clearVariable(theFunction);
[
	#pushItem(theFunction)
	#readIdentifier:theFunction#back
	[','
	 #pushItem(theFunction)
	 #readIdentifier:theFunction#back
	]*
]
;

/*
  definition d'une liste de parametre d'une fonction
*/
parameter_type_list(theFunction : node) ::= 	
	parameter_list(theFunction)
     /* gestion de l'ellipse a part */
     [ 
	[',' 
	| ';' /* GnuC : parameter forward declaration */
	]
       "..."
       => insert theFunction.ellipsis = true;
     ]?
;

/*
  liste de parametre
*/
parameter_list(theFunction : node) ::=
	#pushItem(theFunction)
     	parameter_declaration(theFunction#back)
	[ 
	 [','
	  | ';' /* GnuC : parameter forward declaration */
	  ]
	 #pushItem(theFunction)
	  parameter_declaration(theFunction#back)
	]*
;

/*
  definition d'un parametre de fonction
*/
parameter_declaration(theParam : node) ::=
	/* au minimum un type */
	=> local ctype;
	// cree une reference sur le block parent (resolutions des typedefs)
	=> insert ctype.pctx;
	=> ref ctype.pctx = this.gl_pctx;
	=> cnormCreateCtypeNode(ctype);
	[ declaration_specifier(ctype) ]+
	=> cnormToolTypeNormalizeCType(ctype);
	=> cnormFillDeclarationNode(theParam, "__CTYPE__", ctype);
	=> cnormCreateDeclarationNode(theParam, "__VARIABLE__");
	/* description du nom du parametre 
	   cas complique: on est oblige de faire une copie
	   du node pour matcher soit declarator, soit abstract_declarator
	*/
	=> local nodecopy;
	=> setall nodecopy = theParam;
	[
	 declarator(nodecopy)
	 | 
	 => setall nodecopy = theParam;
	 [ abstract_declarator(nodecopy) ]?:sK
	]
	=> setall theParam = nodecopy;
;

/*
  initialisation des structures et des variables
*/
initializer(theValue : node) ::= 
	'{' #continue 
		=> insert theValue.etype = "init";
		=> insert theValue.block;
		[initializer_list(theValue.block)]? [',']? 
	'}'
	| assignment_expression(theValue)
     => insert theValue.etype = "expression";
;

/*
  liste des valeurs par defaut
*/
initializer_list(theValue : node) ::= 
     #pushItem(theValue) 
     /* c99 */ [#pushItem(theValue#back.designation) designation(theValue#back.designation)]?
     initializer(theValue#back.init)
     [ ',' !'}' #continue // lookahead et continue car on peut terminer sur ,
       #pushItem(theValue) //l'element est detruit si initializer match pas
       /* c99 */ [#pushItem(theValue#back.designation) designation(theValue#back.designation)]?
       initializer(theValue#back.init)
     ]*
;

/*
  c99: designation est une nouvelle construction permettant dans
  la liste des valeurs par defaut de specifier le champs de la structure
  ou l'indice dans le tableau
*/
designation(theType : node) ::= 
	[ '[' 	  
	   [
	    range_expression(theType)	/* GnuC */
	    | constant_expression(theType) 
	   ]	  
	  ']'
	  => insert theType.design = "indexed";
	 | 
	  [
	   '.' identifier:theType.name
	   | identifier:theType.name ':'
          ] => insert theType.design = "fieldname";
	]+ ['=']?
;

/*
  expression d'un type dans une struct et dans un cast
*/
type_name(theType : node) ::= 
	=> local ctype;
	=> insert ctype.pctx;
	=> ref ctype.pctx = this.gl_pctx; // on recupere dans la var global gl_pctx la ref sur l'expression courante
	=> cnormCreateCtypeNode(ctype);
	[ specifier_qualifier(ctype) ]+
	=> cnormToolTypeNormalizeCType(ctype);
	=> cnormFillDeclarationNode(theType, "__CTYPE__", ctype);
	[ abstract_declarator(theType) ]?
;

/*
  l'abstract_declarator et declarator sont semblable
  a qq difference pres mais l'un est pour les type_names (sizeof, cast)
  et l'autre pour les declarators (declaration).
*/
abstract_declarator(theType : node) ::= 
	=> local nodecopy;
	=> setall nodecopy = theType;
[
     [ pointer(nodecopy) ]? direct_abstract_declarator(nodecopy)
     | => setall nodecopy = theType; 
	pointer(nodecopy)
]
	=> setall theType = nodecopy;
;

/*
  pointeur de fonction et tableau au sein d'un typedef.
*/
direct_abstract_declarator(theType : node) ::=
	[ /* pointeur de fonction */
	 '(' 
	 #continue
	 [	 
	 => local nodecopy;
	 pointer(nodecopy)
	 =>
	    {
	      //IOPI:
	      insert theType.pfname;
	      // c'est bien un pointer de fonction
	      foreach indirection in nodecopy.ctype.pointer
	      {
		// on recopie les niveaux de pointeurs comme des niveaux
		// de pointeurs de fonctions. le reste est inchange...
		pushItem theType.pfname;
		if (existVariable(indirection.level))
		  {	insert theType.pfname#back.function;}
		else
		  {	setall theType.pfname#back = indirection;}
	      }
	    }
	 [abstract_declarator(theType.pfname#back.function)]?
	 ]
	 ')'
	 ]?:sP1
	[
	 [ => local subExpr; 
	  /* tableau */
	   '[' #continue
	     [assignment_expression(subExpr) | '*']?:subExpr
	  ']'
	   => cnormFillCtypeNode(theType.ctype, "__ARRAY__", subExpr);
	  ]+
	  | [ /* parametre de fonction */
	     '(' #continue
		#insert(theType.list)
		=> cnormCreateDeclarationNode(theType, "__PROTOTYPE__");
		[ parameter_type_list(theType.list) ]? 
	     ')'
	  ]
	 ]?:sP2
	// une ou l'autre partie de la regle a du matcher
	#check(sP1 != "" || sP2 != "")
=> {
  // cas du pointer de fonction
  if (existVariable(theType.pfname#back.function))
  {
    if (!findElement("typedef", theType.ctype.infoType))
    {	insert theType.type = "__VARIABLE__";}
    else
    {	insert theType.type = "__TYPE__";}
    insert theType.ctype.type = "__PFUNCTION__";
    insert theType.name = theType.pfname#back.function.name;
  }
}
;

/*
  typedef_name match les identifiants qui ont ete insere par un typedef
  dans la liste de type
*/
typedef_name(theType : node) ::=
identifier:sKey
=> local bPrecond = false;
=> local bIsType = cnormToolTypeSearchInTypes(sKey, theType);
=> {
  if (existVariable(theType.identifier)
      && theType.identifier == "__UNDEF__")
  {	bPrecond = true; }
  if (!existVariable(theType.identifier))
  {	bPrecond = true; }
}
#check(bPrecond && bIsType)
=>
  {
    insert theType.type = "__COMPOSED__";
    insert theType.identifier = sKey;
  }
;
