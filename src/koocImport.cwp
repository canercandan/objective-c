/**
 * @file koocImport.cwp
 * @brief \@import grammar
 * @note @ref develop @ref contrib @ref tools
 *
 * @par koocImport
 * rule \@import
 *
 * @par checkFile(file : value, module : value)
 * check if the file exist
 *
 * @par checkModule(module : value, kc : value)
 * check if the module exist
 *
 * @bug les defines ne sont pas copier du .kh au .h
 * il faut accepter les #... lors de explicitCopy@n
 * Repare : mais stocke dans le .c au lieu du .h
 */

/**
 * @cond
 */
koocImport ::= #explicitCopy
  => local module = "";
#try
"@import"
#continue [#readIdentifier:module "from"]?
#continue #readCString:file
#catch(sError)
[
 [checkFile(file, module) => koocManglePopAllBlock();]
 | => errorImport(sError);
 ]
=> indentFile(this.kooc.stack["pathH"], "C++");
[#check(module == "") => koocImportInclude(file);]
#generatedFile(this.kooc.stack["pathC"])
;

checkFile(file : value, module : value) ::=
  => local pathKh = koocImportPathKh(file);
=> insert this.kooc.stack["pathH"] = koocImportPathH(file);
#check(pathKh.existFile())
[
 => deleteFile(this.kooc.stack["pathH"]);
#generatedFile(this.kooc.stack["pathH"])
#parsedFile(pathKh)
 [
  => koocImportIfndef(file);
  => local package_name = "";
  [koocDeclaration(this.block):kc checkModule(module, kc)
   | declaration(this.block)
   => treeInsertFileOut(this.kooc.stack["pathH"]);
   ]*
#continue #empty
  => {@@prettyPrinterToC(this.kooc.stack["pathH"])@@}
  => koocImportEndif(file);
  ]
 ]
| => errorIncludeFile(this.kooc.stack["path_import"] + file);
;

checkModule(module : value, kc : value) ::=
  [
#check(module == "") |
   [=> local name = "";
#parsedString(kc) module(name) => traceLine("kc: " + kc);
    [#check(name != module) => removeVariable(this.kooc.modules[name]);]
    ]
   ]
  ;
/**
 * @endcond
 */
