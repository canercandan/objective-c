/**
 * @file koocImport.cwp
 * @brief \@import grammar
 * @note @ref develop @ref contrib @ref tools
 *
 * @par koocImport
 * rule \@import
 *
 * @par checkFile(file : value, module : value)
 * check if the file exist
 *
 * @par checkModule(module : value, kc : value)
 * check if the module exist
 *
 * @bug les defines ne sont pas copier du .kh au .h
 * il faut accepter les #... lors de explicitCopy@n
 * Repare : mais stocke dans le .c au lieu du .h
 */

/**
 * @cond
 */
koocImport ::= #explicitCopy
  => local module = "";
#try
"@import"
#continue [#readIdentifier:module "from"]?
#continue #readCString:file
#catch(sError)
[
 checkFile(file, module)
 | => errorImport(sError);
 ]
#generatedFile(this.kooc.stack["pathC"])
;

checkFile(file : value, module : value) ::=
  => local pathKh = koocImportPathKh(file);
=> local pathH = koocImportPathH(file);
=> insert this.kooc.stack["pathH"] = pathH;
#check(pathKh.existFile())
[
#check(!this.kooc.headers.findElement(pathH))
 [
  //=> koocImportIfndef(file);
#generatedFile(pathH)
[
#parsedFile(pathKh)
  [
   => local package_name = "";
   [koocDeclaration(this.kooc.headers[pathH].block):kc checkModule(module, kc)
    | declaration(this.block)
    => treeInsertFileOut(this.kooc.stack["pathH"]);
    ]*
#continue #empty
   //=> treeCopyInfos(this.kooc.headers[pathH].block);
   //=> prettyPrintExistFile(pathH, this.kooc.headers[pathH]);
   => {%>#ifndef ____@"\n"@<%}
   => {@@r00t()@@}
   => {%>#endif ____@"\n"@<%}
   ]
 ]
=> indentFile(pathH, "C++");
//=> koocImportEndif(file);
  [#check(module == "") => koocImportInclude(file);]
  ]
 ]
| => errorIncludeFile(this.kooc.stack["path_import"] + file);
;

checkModule(module : value, kc : value) ::=
  [
#check(module == "") |
   [=> local name = "";
#parsedString(kc) module(name) => traceLine("kc: " + kc);
    [#check(name != module) => removeVariable(this.kooc.modules[name]);]
    ]
   ]
  ;
/**
 * @endcond
 */
