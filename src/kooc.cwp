/**
 * @file kooc.cwp
 * @brief Kooc Grammar file
 * @note @ref develop @ref contrib @ref tools
 *
 * @par ImplicitCopy
 *
 * @par #ignore["KOOC"]
 * ignore backslash notation and comment of language
 *
 * @par translation_unit
 * it's the root rule (overload of Cnorm)
 *
 * @par koocDeclaration(block : node)
 * it's a rule which parse a import, module, implementation
 * or kooc expression
 */

#include "../cnorm_2.6/src/cnorm.cwp"
#include "koocPrettyPrinter.inc.cws"
#include "koocMangle.inc.cws"
#include "koocError.inc.cws"
#include "koocImport.inc.cws"
#include "koocClass.inc.cws"
#include "koocImplementation.inc.cws"
#include "koocModule.inc.cws"
#include "koocCall.inc.cws"
#include "koocTools.inc.cws"
#include "koocMember.inc.cws"

/**
 * @cond
 */
#explicitCopy

#ignore["KOOC"] ::=
[#implicitCopy
 ['#' ->[['\r']? '\n']]
 | ["//" ->[['\r']? '\n']]
 | ["/*" ->"*/"]
 | ' ' | '\t' | '\n' | '\r' | '\f'
 ]+
;

#overload translation_unit ::=
#ignore("KOOC")
#try
[koocDeclaration(this.block)
 | declaration(this.block)
 => treeInsertFileOut(this.kooc.stack["pathC"]);
]*
#continue
#empty
#catch (sError)
[
 => {@@prettyPrinterToC(this.kooc.stack["pathC"])@@}
 ]
|
//=> traceObject(this, 4);
=> errorDebug(sError);
;

koocDeclaration(block : node) ::=
  [ koocImport | koocModule | koocImplementation |
    koocClass | koocCall(block) | koocPackage ]
;
/**
 * @endcond
 */

#overload declaration(theBlock : node) ::=
';'
| [
#pushItem(theBlock)
   => insert theBlock#back.__LINE__ = countInputLines();
   [
    asm_expr:theBlock#back.asm
    => insert theBlock#back.otype = "asmexpr";
    => insert theBlock#back.etype = "expression";
    | [
       => local ctype;
       => insert ctype.pctx;
       => ref ctype.pctx = this.gl_pctx;
       => cnormCreateCtypeNode(ctype);
       [ declaration_specifier(ctype) ]+
       => cnormToolTypeNormalizeCType(ctype);
       => cnormFillDeclarationNode(theBlock#back, "__CTYPE__", ctype);
       => cnormCreateDeclarationNode(theBlock#back, "__VARIABLE__");
       => cnormCheckTypeDeclaration(theBlock#back);
       init_declarator(theBlock#back)
       //=> traceObject(theBlock#back);
       => local aType;
       => {
	 setall aType.type = theBlock#back.type;
	 setall aType.ctype = theBlock#back.ctype;
	 setall aType.etype = theBlock#back.etype;
       }
       [
#check(!(theBlock#back.type == "__FUNCTION__" &&
	 existVariable(theBlock#back.block)))
	 [ ','
#pushItem(theBlock)
	   => setall theBlock#back = aType;
	   init_declarator(theBlock#back)
	   ]*
	 ';'
	 | => local empty;
	]
       ]
    ]
   ]
;

#overload declarator(theType : node) ::=
#super::declarator(theType)
=>
{
  insert theType.oname = theType.name;
  if (theType#parent#parent.type != "__FUNCTION__" &&
      theType#parent#parent.type != "__COMPOSED__" &&
      !equalTrees(theType, theType#parent))
    theType.name = koocMangle(theType);
}
;

#include "koocImport.cwp"
#include "koocModule.cwp"
#include "koocImplementation.cwp"
#include "koocMember.cwp"
#include "koocClass.cwp"
#include "koocCall.cwp"
#include "koocPackage.cwp"
#include "koocVirtual.cwp"