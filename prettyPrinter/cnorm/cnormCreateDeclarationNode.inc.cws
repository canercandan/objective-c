/*
**	cnormCreateDeclarationNode.inc.cws
**	for LSE - cnorm
**	made by amsall_d and giron_d
**	review by auroux_l
*/

/*
**	function (void)		cnormCreateDeclarationNode(theDeclaration : node, type : value)
**	function (void)         cnormFillVariableDeclarationNode(ctype : node, command : value, arg : value)
**	function (void)         cnormFillTypeDeclarationNode(ctype : node, command : value, arg : value)
**	function (void)         cnormFillFunctionDeclarationNode(ctype : node, command : value, arg : value)
**	function (void)         cnormFillPrototypeDeclarationNode(ctype : node, command : value, arg : value)
*/

function	cnormCreateDeclarationNode(theDeclaration : node, type : value)
/*
  This function creates a basic empty declaration node that
  can be filled safely by the functions
  cnormFillVariableDeclarationNode(ctype : node, command : node, arg : node)
  cnormFillTypeDeclarationNode(ctype : node, command : node, arg : node)
  cnormFillFuntionDeclarationNode(ctype : node, command : node, arg : node)
  cnormFillPrototypeDeclarationNode(ctype : node, command : node, arg : node)
*/
{
  // we never erase somethings already done
  //if (theDeclaration.type != "" && theDeclaration.type != "__UNDEF__")
  //  return;
  // ... no type already set, ok let's go
  switch (type)
    {
    case "__VARIABLE__":
      {
	insert theDeclaration.type = "__VARIABLE__";
	insert theDeclaration.etype = "declaration";
	return;
	break;
      }
    case "__TYPE__":
      {
	insert theDeclaration.type = "__TYPE__";
	return;
	break;
      }
    case "__PROTOTYPE__":
      {
	insert theDeclaration.type = "__PROTOTYPE__";
	return;
	break;
      }
    case "__FUNCTION__":
      {
	insert theDeclaration.type = "__FUNCTION__";
	return;
	break;
      }
    default:
      {
	cnormError("Unhandled declaration type [" + type +"]");
	break;
      }
    }
  return;
}

function	cnormCheckTypeDeclaration(theDeclaration : node)
/*
  When we make type we didn't have all information. So we make an 
  inconsistent Node. This function check, if it was a type construction
  and so, correct it.
*/
{
  if (existVariable(theDeclaration.ctype)
      && existVariable(theDeclaration.ctype.infoType)
      && findElement("typedef", theDeclaration.ctype.infoType))
    {
      theDeclaration.type = "__TYPE__";
    }
}

function	cnormFillDeclarationNode(theDeclaration : node, command : value, arg : node)
/*
  This function is used to error safely fill a declaration Node
*/
{
  switch (command)
    {
    case "__NAME__":
      {
	cnormToolDeclarationNode_setDeclarationName(theDeclaration, arg);
	return;
	break;
      }
    case "":
      {
	local generatedName = cnormToolDeclarationNode_genName();
	cnormToolDeclarationNode_setDeclarationName(theDeclaration, arg);
	return;
	break;
      }
    case "__CTYPE__":
      {
	cnormToolDeclarationNode_setDeclarationCtype(theDeclaration, arg);
	return;
	break;
      }
    case "__LIST__":
      {
	cnormToolDeclarationNode_setDeclarationList(theDeclaration, arg);
	return;
	break;
      }
    case "__BLOCK__":
      {
	cnormToolDeclarationNode_setDeclarationBlock(theDeclaration, arg);
	return;
	break;
      }
    default:
      {
	cnormError("Unknown Decalartion node command: [" + command + "]");
	break;
      }
    }
  return;
}

/*
example:

root ::=
	=> local ctype;
	=> local declaration;
	=> local name;
	=> {

		cnormCreateCtypeNode(ctype);

		cnormFillCtypeNode(ctype, "__INFOTYPE__", "const");
		cnormFillCtypeNode(ctype, "__TYPEID__", "char");
		cnormFillCtypeNode(ctype, "__POINTER__", "*");
		cnormFillCtypeNode(ctype, "__POINTER__", "*");
		cnormFillCtypeNode(ctype, "__POINTER__", "const");
		cnormFillCtypeNode(ctype, "__POINTER__", "*");
	       
		cnormCreateDeclarationNode(declaration, "__VARIABLE__");

		name = "a";
		cnormFillDeclarationNode(declaration, "__NAME__", name);
		cnormFillDeclarationNode(declaration, "__CTYPE__", ctype);

		traceObject(declaration, 3);
	}
;

*/
